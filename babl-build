#!/usr/bin/env ruby

require 'yaml'
require 'json'
require 'net/http'
require 'thor'
require 'active_support/core_ext/hash'



class CLI < Thor

  def self.overwrites
    @overwrites ||= begin
      file = '.babl-build.yml'
      if File.readable? file
        YAML.load_file(file).deep_symbolize_keys!
      else
        {}
      end
    end
  end

  class_option :dry_run, type: :boolean, default: false
  class_option :config_file, default: "#{Dir.home}/.babl/build-config.yml"
  class_option :marathon_host, default: "127.0.0.1"



  no_commands do

    def _module
      @_module ||= File.basename(Dir.pwd)
    end

    def id
      "#{type}-#{_module}"
    end

    def type
      (env = self.class.overwrites[:env] and env[:SERVICE_TAGS]) or 'babl'
    end

    def container_options
      ((c = self.class.overwrites[:container] and c[:options]) or []).join ' '
    end

    def _version
      'v' + `git rev-list HEAD --count`.strip
    end

    def image
      "registry.babl.sh:5000/#{id}:#{_version}"
    end

    def conf
      @conf ||= begin
        c = YAML.load_file(options[:config_file]).deep_symbolize_keys!
        c = c.deep_merge(self.class.overwrites)
        c[:id] = id
        c[:container][:docker][:image] = image
        c[:env][:BABL_MODULE] = _module
        c
      end
    end

    def execute cmd
      puts cmd
      unless options[:dry_run]
        unless system cmd
          exit $?.exitstatus
        end
      end
    end

  end



  desc "build MODULE", "Build Docker image for MODULE"
  option :no_cache, type: :boolean, default: false
  def build
    execute "docker build -t #{image}#{" --no-cache" if options[:no_cache]} ."
    latest = image.sub(/:[^:]+$/, ':latest')
    execute "docker tag -f #{image} #{latest}"
  end


  desc "version", "Prints the current version to be deployed if VERSION file is available"
  def version
    puts _version
  end


  desc "config MODULE", "Print the Marathon JSON config for MODULE"
  def config
    puts JSON.dump conf
  end


  desc "push MODULE", "Push Docker image for MODULE to remote registry"
  def push
    execute "docker push #{image}"
  end


  desc "deploy MODULE", "Deploy a Babl module"
  def deploy
    uri = URI("http://#{options[:marathon_host]}:8080/v2/apps")
    req = Net::HTTP::Post.new(uri)
    req.body = JSON.dump conf
    req.content_type = 'application/json'

    res = Net::HTTP.start(uri.hostname, uri.port) do |http|
      http.request(req)
    end

    case res
    when Net::HTTPSuccess, Net::HTTPRedirection
      puts res.body
    else
      res.value
    end
  end


  desc "destroy MODULE", "Destroy a Babl module"
  def destroy
    execute "curl -s -X DELETE 'http://#{options[:marathon_host]}:8080/v2/apps/#{id}'"
  end

  desc "dist MODULE", "build & push & destroy & deploy"
  def dist
    build
    push
    destroy
    deploy
  end

  desc "play MODULE", "Plays (runs) a local built Babl module for development/debugging purpose"
  def play
    execute "docker run -it --rm -p 4444:4444 -e BABL_MODULE=#{_module} -e BABL_COMMAND=/bin/app #{container_options} #{image}"
  end

  desc "sh", "Runs the container with a shell"
  def sh
    execute "docker run -it --rm -p 4444:4444 -e BABL_MODULE=#{_module} -e BABL_COMMAND=/bin/app #{container_options} #{image} sh"
  end

end


CLI.start(ARGV)
